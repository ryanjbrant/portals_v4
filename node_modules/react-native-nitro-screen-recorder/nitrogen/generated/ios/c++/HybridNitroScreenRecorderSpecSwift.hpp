///
/// HybridNitroScreenRecorderSpecSwift.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

#include "HybridNitroScreenRecorderSpec.hpp"

// Forward declaration of `HybridNitroScreenRecorderSpec_cxx` to properly resolve imports.
namespace NitroScreenRecorder { class HybridNitroScreenRecorderSpec_cxx; }

// Forward declaration of `PermissionStatus` to properly resolve imports.
namespace margelo::nitro::nitroscreenrecorder { enum class PermissionStatus; }
// Forward declaration of `PermissionResponse` to properly resolve imports.
namespace margelo::nitro::nitroscreenrecorder { struct PermissionResponse; }
// Forward declaration of `ScreenRecordingEvent` to properly resolve imports.
namespace margelo::nitro::nitroscreenrecorder { struct ScreenRecordingEvent; }
// Forward declaration of `RecordingEventType` to properly resolve imports.
namespace margelo::nitro::nitroscreenrecorder { enum class RecordingEventType; }
// Forward declaration of `RecordingEventReason` to properly resolve imports.
namespace margelo::nitro::nitroscreenrecorder { enum class RecordingEventReason; }
// Forward declaration of `BroadcastPickerPresentationEvent` to properly resolve imports.
namespace margelo::nitro::nitroscreenrecorder { enum class BroadcastPickerPresentationEvent; }
// Forward declaration of `RecorderCameraStyle` to properly resolve imports.
namespace margelo::nitro::nitroscreenrecorder { struct RecorderCameraStyle; }
// Forward declaration of `CameraDevice` to properly resolve imports.
namespace margelo::nitro::nitroscreenrecorder { enum class CameraDevice; }
// Forward declaration of `ScreenRecordingFile` to properly resolve imports.
namespace margelo::nitro::nitroscreenrecorder { struct ScreenRecordingFile; }
// Forward declaration of `RecordingError` to properly resolve imports.
namespace margelo::nitro::nitroscreenrecorder { struct RecordingError; }

#include "PermissionStatus.hpp"
#include "PermissionResponse.hpp"
#include <NitroModules/Promise.hpp>
#include "ScreenRecordingEvent.hpp"
#include <functional>
#include "RecordingEventType.hpp"
#include "RecordingEventReason.hpp"
#include "BroadcastPickerPresentationEvent.hpp"
#include "RecorderCameraStyle.hpp"
#include <optional>
#include "CameraDevice.hpp"
#include "ScreenRecordingFile.hpp"
#include <string>
#include "RecordingError.hpp"

#include "NitroScreenRecorder-Swift-Cxx-Umbrella.hpp"

namespace margelo::nitro::nitroscreenrecorder {

  /**
   * The C++ part of HybridNitroScreenRecorderSpec_cxx.swift.
   *
   * HybridNitroScreenRecorderSpecSwift (C++) accesses HybridNitroScreenRecorderSpec_cxx (Swift), and might
   * contain some additional bridging code for C++ <> Swift interop.
   *
   * Since this obviously introduces an overhead, I hope at some point in
   * the future, HybridNitroScreenRecorderSpec_cxx can directly inherit from the C++ class HybridNitroScreenRecorderSpec
   * to simplify the whole structure and memory management.
   */
  class HybridNitroScreenRecorderSpecSwift: public virtual HybridNitroScreenRecorderSpec {
  public:
    // Constructor from a Swift instance
    explicit HybridNitroScreenRecorderSpecSwift(const NitroScreenRecorder::HybridNitroScreenRecorderSpec_cxx& swiftPart):
      HybridObject(HybridNitroScreenRecorderSpec::TAG),
      _swiftPart(swiftPart) { }

  public:
    // Get the Swift part
    inline NitroScreenRecorder::HybridNitroScreenRecorderSpec_cxx& getSwiftPart() noexcept {
      return _swiftPart;
    }

  public:
    inline size_t getExternalMemorySize() noexcept override {
      return _swiftPart.getMemorySize();
    }
    void dispose() noexcept override {
      _swiftPart.dispose();
    }
    std::string toString() override {
      return _swiftPart.toString();
    }

  public:
    // Properties
    

  public:
    // Methods
    inline PermissionStatus getCameraPermissionStatus() override {
      auto __result = _swiftPart.getCameraPermissionStatus();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline PermissionStatus getMicrophonePermissionStatus() override {
      auto __result = _swiftPart.getMicrophonePermissionStatus();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::shared_ptr<Promise<PermissionResponse>> requestCameraPermission() override {
      auto __result = _swiftPart.requestCameraPermission();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::shared_ptr<Promise<PermissionResponse>> requestMicrophonePermission() override {
      auto __result = _swiftPart.requestMicrophonePermission();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline double addScreenRecordingListener(bool ignoreRecordingsInitiatedElsewhere, const std::function<void(const ScreenRecordingEvent& /* event */)>& callback) override {
      auto __result = _swiftPart.addScreenRecordingListener(std::forward<decltype(ignoreRecordingsInitiatedElsewhere)>(ignoreRecordingsInitiatedElsewhere), callback);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline void removeScreenRecordingListener(double id) override {
      auto __result = _swiftPart.removeScreenRecordingListener(std::forward<decltype(id)>(id));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline double addBroadcastPickerListener(const std::function<void(BroadcastPickerPresentationEvent /* event */)>& callback) override {
      auto __result = _swiftPart.addBroadcastPickerListener(callback);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline void removeBroadcastPickerListener(double id) override {
      auto __result = _swiftPart.removeBroadcastPickerListener(std::forward<decltype(id)>(id));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void startInAppRecording(bool enableMic, bool enableCamera, const RecorderCameraStyle& cameraPreviewStyle, CameraDevice cameraDevice, const std::function<void(const ScreenRecordingFile& /* file */)>& onRecordingFinished) override {
      auto __result = _swiftPart.startInAppRecording(std::forward<decltype(enableMic)>(enableMic), std::forward<decltype(enableCamera)>(enableCamera), std::forward<decltype(cameraPreviewStyle)>(cameraPreviewStyle), static_cast<int>(cameraDevice), onRecordingFinished);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline std::shared_ptr<Promise<std::optional<ScreenRecordingFile>>> stopInAppRecording() override {
      auto __result = _swiftPart.stopInAppRecording();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::shared_ptr<Promise<void>> cancelInAppRecording() override {
      auto __result = _swiftPart.cancelInAppRecording();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline void startGlobalRecording(bool enableMic, const std::function<void(const RecordingError& /* error */)>& onRecordingError) override {
      auto __result = _swiftPart.startGlobalRecording(std::forward<decltype(enableMic)>(enableMic), onRecordingError);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline std::shared_ptr<Promise<std::optional<ScreenRecordingFile>>> stopGlobalRecording(double settledTimeMs) override {
      auto __result = _swiftPart.stopGlobalRecording(std::forward<decltype(settledTimeMs)>(settledTimeMs));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::optional<ScreenRecordingFile> retrieveLastGlobalRecording() override {
      auto __result = _swiftPart.retrieveLastGlobalRecording();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline void clearRecordingCache() override {
      auto __result = _swiftPart.clearRecordingCache();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }

  private:
    NitroScreenRecorder::HybridNitroScreenRecorderSpec_cxx _swiftPart;
  };

} // namespace margelo::nitro::nitroscreenrecorder
